Python
参考：

大厂面经：https://learnku.com/articles/39504

110道题：https://zhuanlan.zhihu.com/p/54430650

垃圾回收：https://blog.csdn.net/xiongchengluo1129/article/details/80462651

- **三次握手 / 四次握手的过程？**
- **为什么要三次握手和四次挥手？**
- **cp？udp？http？ip 属于哪些层？作用？**
- **TCP 具体是通过怎样的方式来保证数据的顺序化传输、可靠传输呢？**
- **python 中可变数据类型和不可变数据类型？**
- **非关系数据库可以做什么？其中关系数据库不可以吗？为什么？非关系数据库和关系数据库的区别。**
- **输入 url 之后显示的网页的全过程？**
- **服务器上为什么要进行反向代理？不进行反向代理外面访问端口就不能访问了吗？**
- **get/post 区别？**
- **nginx 作用？谁来做监听？**
- **装饰器的作用？**
- **进程和线程？两个的区别？**
- **同进程中的不同线程如何通信？**
- **线程共享堆栈吗？**
- **python 垃圾回收**
- **软件工程的单例模式 / 软件工程有哪些模式**

MySQL

### MVVC

##### 1. 事物的特性

- 原子性：一个事物是一个最小的操作单位（原子性），多条sql语句在一个事物中要么同时成功，要么同时失败
- 一致性：事务提交之前喝回滚之后的数据是一致的
- 持久性：事物一旦提交，对数据的影响是持久的
- 隔离性：多个事物在并发访问下，提供了一套隔离机制，不同的隔离级别会有不同的并发效果

##### 2. 事物的隔离级别

read uncommitted（读未提交）：在一个事物中读取到的另一个还没有提交的数据，会出现——`脏读`

read committed（读已提交）：已经解决了脏读问题，在一个事物中只能读取另一个事物已提交的数据，这种情况会出现`不可重复读`的问题：在事物中重复读数据，数据的内容是不一样的

repeatable read（可重复读）（默认级别）：在一个事物中每次读取到的数据都是一致的，不会出现脏读和不可重复读的问题。但是会出现——虚读（幻读）：两个事物中同时查询了表中数据，一个事物提交了数据更改，另一个事物提交了相同的数据更改会提示`主键重复`，但是这个事物查询到的数据并没有相同主键的id。因为MVCC的版本控制问题，事物A提交了数据，事物B查询的数据不是最新的数据，但是每次做写操作时MVCC都会先去查最新的版本，而再最新的版本中已经有了相同的主键，所以事物B无法二次插入。但是因为查询的数据并没有相同的主键所以仿佛是幻觉一样。

解决虚读：通过上行锁解决虚读问题。

上行锁成功：其他事物需要等待该条数据成功执行后再执行，哪怕插入相同数据其余事物也会等待后失败。

上行锁失败：其他事物正在对该条数据做写入操作（InnoDB在事物中对数据做写操作自动上行锁），所以该事物无法直接上行锁直到其他事物提交数据后该事物才能上行锁程功。如果其他事物和该事物插入的数据一样，该事物上行锁的select会有数据，再对比该数据和该事物要插入的数据对比选择是否继续插入数据。

Serializable（串行化）：串行化的隔离级别不允许任何并发发生，不存在任何并发问题。相当于锁表，性能非常差，一般都不考虑。

#### 3.MVCC思想解读

MySQL在读和写的操作中，对读的性能做了并发的保障，让所有的读都是快照读，对于写的时候进行版本控制，如果真实数据的版本比快照的版本要新，那么写之前就要进行版本（快照）更新，这样就可以既能够提高读的并发性，又能够保证写的数据安全



Redis

穿透：

大量访问无效URL，缓存没有只能在数据库里查找，增加数据库压力，但数据库也没有的无效访问

击穿

某个缓存key过期，瞬时间对该数据大量访问（如热搜），导致数据库压力增大

雪崩

大量缓存key集中过期，导致大量访问查询数据库，导致数据库压力增大

分布式锁：多台机器上同一把锁

独占锁

setex key value nx ex second（nx：上锁 ex：设置过期时间）

RabbitMQ

四种链接模型

```python

```

Docker

```python
docker pull --platform linux/x86_64 mysql
```

Git

```python

```