# Python
参考：

大厂面经：https://learnku.com/articles/39504

110道题：[python面试题答案.md](./python面试题答案.md)

垃圾回收：https://blog.csdn.net/xiongchengluo1129/article/details/80462651

- **三次握手 / 四次挥手的过程？**

> ​	参考：https://juejin.cn/post/6844904070000410631

> 

- **为什么要三次握手和四次挥手？**

  > 

- **tcp？udp？http？ip ?属于哪些层？作用？**

  > tcp、udp：传输层
  >
  > 在此层中，它提供了节点间的数据传送，应用程序之间的通信服务，主要功能是数据格式化、数据确认和丢失重传等。如传输控制协议(TCP)、用户数据报协议(UDP)等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。

  

  > http：应用层 
  >
  > 应用程序间沟通的层，如简单电子邮件传输(SMTP)、文件传输协议(FTP)、网络远程访问协议(Telnet)等。

  

  > ip：网络层
  >
  > 接收IP数据报并进行传输，从网络上接收物理帧，抽取IP数据报转交给下一层，对实际的网络媒体的管理，定义如何使用实际网络(如Ethernet、Serial Line等)来传送数据。

  

- **TCP 具体是通过怎样的方式来保证数据的顺序化传输、可靠传输呢？**

> 1. 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认
>
> 2. 如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。
>
> 3. 接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等
>
> 4. 接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理

- **python 中可变数据类型和不可变数据类型？**

> 不可变：`int`（整型）、`string`（字符串）、`tuple`（元组）
>
> 可变：set（集合）、list（列表）、dict（字典）

- **非关系数据库可以做什么？其中关系数据库不可以吗？为什么？非关系数据库和关系数据库的区别。**

  > 

- **输入 url 之后显示的网页的全过程？**

  > https://zhuanlan.zhihu.com/p/133906695

- **服务器上为什么要进行反向代理？不进行反向代理外面访问端口就不能访问了吗？**

  > 反向代理（ReverseProxy）是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端,简单来说就是真实的服务器不能直接被外部网络访问,想要访问必须通过代理。

  > 不进行反向代理外面访问端口可以访问，但反向代理服务器可以做的更好

- **get/post 区别？**

  > - GET在浏览器回退时是无害的，而POST会再次提交请求。
  > - GET产生的URL地址可以被Bookmark，而POST不可以。
  > - GET请求会被浏览器主动cache，而POST不会，除非手动设置。
  > - GET请求只能进行url编码，而POST支持多种编码方式。
  > - GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
  > - GET请求在URL中传送的参数是有长度限制的，而POST没有。
  > - 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
  > - GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
  > - GET参数通过URL传递，POST放在Request body中

- **nginx 作用？谁来做监听？**

  > nginx服务器有什么作用？
  >
  > 1、反向代理
  >
  > 2、负载均衡
  >
  > 3、动静分离

- **装饰器的作用？**

  参考：https://foofish.net/python-decorator.html

  > 装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

- **进程和线程？两个的区别？**

  > 

- **同进程中的不同线程如何通信？**

  > 

- **线程共享堆栈吗？**

  > 

- **python 垃圾回收**

  > 

- **软件工程的单例模式 / 软件工程有哪些模式**

  > 

# Flask

https://www.shangmayuan.com/a/6856476b555f4c4ab9d64ef3.html

https://blog.csdn.net/thanlon/article/details/100718075

https://blog.csdn.net/qq_41891803/article/details/81272575

https://www.modb.pro/db/211218

- **Flask框架的优点**

  > Flask是一个Python编写的Web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。

- **Flask框架依赖组件**

  > - Route(路由)
  > - templates(模板)
  > - Models(orm模型)
  > - blueprint(蓝图)
  > - Jinja2模板引擎

- **列举使用过的Flask第三方组件**

  > - `flask_bootstrap`
  > - `flask-WTF`
  > - `flask_sqlalchemy`
  > - `werkzurg`
  > - `DBUtils`
  > - `jinjia二`
  > - `redis`
  > - `sql`

- **简述Flask上下文管理流程**

  > 每次有请求过来的时候，flask 会先创建当前线程或者进程需要处理的两个重要上下文对象，把它们保存到隔离的栈里面，这样视图函数进行处理的时候就能直接从栈上获取这些信息。

  1. 请求到来时，将session和request封装到ctx对象中；
  2. 对session作补充；
  3. 将包含了request和session的ctx对象放到一个容器中（每一个请求都会根据线程/协程加一个惟一标识）；
  4. 视图函数使用的时候须要根据当前线程或协程的惟一标识，获取ctx对象，再取ctx对象中取request和session（视图函数使用的时候，须要根据当前线程获取数据。）5.请求结束时，根据当前线程/协程的惟一标记，将这个容器上的数据移除。

- **Flask中的g的做用**

  > Flask的g对象用作全局命名空间，用于在应用程序上下文中保存任何数据。g对象不适用于在请求之间存储数据。从某种意义上说，字母g代表global。在某些情况下，当您需要在应用程序上下文中保留全局变量，而不是创建全局变量时，最好使用g对象，因为Flask中的每个请求都有一个单独的g对象。Flask的g对象使我们免于意外修改自定义全局变量。

- **Flask中上下文管理主要涉及到了哪些相关的类，这些类的主要做用**

  > `1. LocalStack它帮助咱们在local中把一个列表维护成一个栈，方便咱们对列表中的数据进行添加和维护，有了LocalStack操做更加便捷。`
  >
  > `2. Local帮助咱们为每一个线程/协程开辟空间`fla

- **为何Flask要把Local对象中的值stack维护成一个列表**

  > ```python
  > # 因为通过维护成列表，可以实现一个栈的数据结构，进栈出栈时只取一个数据，巧妙的简化了问题。
  > # 还有，在多app应用时，可以实现数据隔离；列表里不会加数据，而是会生成一个新的列表
  > # local是一个字典，字典里key（stack）是唯一标识，value是一个列表
  > ```

- **Flask中多app应用是怎么完成**

  > 请求进来时，可以根据URL的不同，交给不同的APP处理
  >
  > `使用Flask类建立不一样的app对象，而后借助DispatcherMiddleware类来实现。`cookie

- **在Flask中实现WebSocket须要什么组件**

  > flask_socketio

- **wtforms组件的做用**

  > WTForms是一个支持多个web框架的form组件，主要用于对用户请求数据进行验证。
  >
  > `wtforms组件有两个做用，自动生成html标签和对用户请求数据进行校验。`session

- **Flask框架默认session的处理机制**

  > Flask的默认session利用了Werkzeug的SecureCookie，把信息做序列化(pickle)后编码(base64)，放到cookie里了。
  >
  > 过期时间是通过cookie的过期时间实现的。
  >
  > 为了防止cookie内容被篡改，session会自动打上一个叫session的hash串，这个串是经过session内容、SECRET_KEY计算出来的，看得出，这种设计虽然不能保证session里的内容不泄露，但至少防止了不被篡改
  >
  > 
  >
  > 当请求刚进来时，Flask读取cookie中session对应的值，将该值解密并反序列化为字典，放入内存以便视图函数使用。 当请求结束时，Flask会读取内存中字典的值，进行序列化加密，写入到用户的cookie中。

- **解释Flask框架中的Local对象和threading.local对象的区别**

  > `Local对象是根据threading.local作的app

- **Flask中 blinker 是什么**

  > ```python
  > request_started = _signals.signal('request-started')                # 请求到来前执行
  > request_finished = _signals.signal('request-finished')              # 请求结束后执行
  >  
  > before_render_template = _signals.signal('before-render-template')  # 模板渲染前执行
  > template_rendered = _signals.signal('template-rendered')            # 模板渲染后执行
  >  
  > got_request_exception = _signals.signal('got-request-exception')    # 请求执行出现异常时执行
  >  
  > request_tearing_down = _signals.signal('request-tearing-down')      # 请求执行完毕后自动执行（无论成功与否）
  > appcontext_tearing_down = _signals.signal('appcontext-tearing-down')# 请求上下文执行完毕后自动执行（无论成功与否）
  >  
  > appcontext_pushed = _signals.signal('appcontext-pushed')            # 请求上下文push时执行
  > appcontext_popped = _signals.signal('appcontext-popped')            # 请求上下文pop时执行
  > message_flashed = _signals.signal('message-flashed')                # 调用flask在其中添加数据时，自动触发
  > ```
  >
  > 

- **SQLAlchemy中的session和scoped_session的区别**

  > ```
  > 使用的scoped_session是基于Threading.Local实现的，而session并非。
  > ```

- **SQLAlchemy如何执行原生SQL**

  > ```python
  > # 两种SQLAlchemy可以执行原生sql的方式，第一种是通过session(会话)对象执行execute方法，第二种是通过cursor(游标)对象执行execute方法。
  > 
  > """
  > 第一种是：
  > """
  > session = scoped_session(SessionFactory)
  > session.execute('insert users(name) values(:value)', params={'value': 'thanlon'})
  > 
  > """
  > 第二种是：
  > """
  > conn = engine.raw_connection()
  > cursor = conn.cursor()
  > cursor.execute('select * from users')
  > ```
  >
  > 

- **ORM的实现原理**

  > 概念： 对象关系映射（Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。
  >
  > 详细介绍：让我们从O/R开始。字母O起源于”对象”(Object),而R则来自于”关系”(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。 
  > 当你开发一个应用程序的时候(不使用O/R Mapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 
  > ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。
  >
  > ORM技术特点：
  >
  > 1.提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 
  > 2.ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。

- **DBUtils模块的做用**

  > DBUtils模块的作用是实现数据库连接池，是为了解决“多线程情况下请求比较多时性能降低”的问题。

- **SQLAchemy中如何为表设置引擎和字符编码**

  > ```python
  > # 设置引擎编码方式为utf8。    
  > engine = create_engine("mysql+pymysql://user:password@127.0.0.1:3306/db01?charset=utf8")
  > 
  > # 设置数据库表编码方式为utf8class UserType(Base):    
  > class UserType(Base):
  >     __tablename__ = 'usertype'
  >     id = Column(Integer, primary_key=True)
  >     caption = Column(String(50), default='管理员')
  >     # 添加配置设置编码
  >     __table_args__ = {
  >         'mysql_charset':'utf8'
  >     }
  > 
  > ```
  >
  > 

- **SQLAchemy中如何设置联合惟一索引**

  > ```python
  > # 首先在中间表(关联表)的类中加入__table_args__ 字段，然后实例化UniqueConstraint类并放入一个元组中，最后把这个元组赋值给__table_args__。用代码表示如下：
  > 
  > __table_args__ = (
  >         UniqueConstraint('student_id', 'course_id', name='uc_student_course'),  # 联合唯一索引
  >     )
  > ```
  >
  > 

- **Flask请求相关的数据和Django的区别**

  > ```
  > Flask是直接调用request对象来请求相关的数据，而Django是经过参数传递实现的。
  > ```

- **Flask和Django最大的区别**

  > Flask
  >
  > Flask确实很“轻”，不愧是Micro Framework，从Django转向Flask的开发者一定会如此感慨，除非二者均为深入使用过
  > Flask自由、灵活，可扩展性强，第三方库的选择面广，开发时可以结合自己最喜欢用的轮子，也能结合最流行最强大的Python库
  > 入门简单，即便没有多少web开发经验，也能很快做出网站
  > 非常适用于小型网站
  > 非常适用于开发web服务的API
  > 开发大型网站无压力，但代码架构需要自己设计，开发成本取决于开发者的能力
  > 各方面性能均等于或优于Django
  > Django自带的或第三方的好评如潮的功能，Flask上总会找到与之类似第三方
  > Flask灵活开发，Python高手基本都会喜欢Flask，但对Django却可能褒贬不
  > Flask与关系型数据库的配合使用不弱于Django，而其与NoSQL数据库的配合远远优于Django
  > Flask比Django更加Pythonic，与Python的philosophy更加吻合
  >
  > 
  >
  > Django
  >
  > Django太重了，除了web框架，自带ORM和模板引擎，灵活和自由度不够高
  > Django能开发小应用，但总会有“杀鸡焉用牛刀”的感觉
  > Django的自带ORM非常优秀，综合评价略高于SQLAlchemy
  > Django自带的模板引擎简单好用，但其强大程度和综合评价略低于Jinja2
  > Django自带ORM也使Django与关系型数据库耦合度过高，如果想使用MongoDB等NoSQL数据，需要选取合适的第三方库，且总感觉Django+SQL才是天生一对的搭配，Django+NoSQL砍掉了Django的半壁江山
  > Django目前支持Jinja等非官方模板引擎
  > Django自带的数据库管理app好评如潮
  > Django非常适合企业级网站的开发：快速、靠谱、稳定
  > Django成熟、稳定、完善，但相比于Flask，Django的整体生态相对封闭
  > Django是Python web框架的先驱，用户多，第三方库最丰富，最好的Python库，如果不能直接用到Django中，也一定能找到与之对应的移植
  > Django上手也比较容易，开发文档详细、完善，相关资料丰富

- **Flask若是开了两个进程，有几个local对象**

  > 上线文：https://blog.csdn.net/feit2417/article/details/80735590

- **Flask-WTF是什么，有什么特点？**

  > Flask的简单WTForms集成，包含CSRF、文件上传和Recaptcha集成。
  >
  > flask-wtf可以保护表单免受跨站请求伪造（CSRF）的攻击,恶意网站将请求发送到被攻击者已登录的其他网站时就会引发CSRF

- **Flask脚本的常用方式是什么?**

  > - 在shell中运行脚本文件
  > - 在python编译器中run

- **如何在Flask中访问会话?**

  > 一个会话基本上允许记住从一个请求到另一个请求的信息。在Flask中，它使用签名的cookie，以便用户可以查看会话内容并进行修改。用户可以修改会话，只要它有密钥Flask.secret_key。
  >
  > 
  >
  > 会话（seesion）会话数据存储在服务器上。 会话是客户端登录到服务器并注销的时间间隔。 需要在此会话中进行的数据存储在服务器上的临时目录中。
  > from flask import session导入会话对象
  > session[‘name’] = ‘admin’给会话添加变量
  > session.pop(‘username’, None)删除会话的变量

- **Flask是一个MVC模型吗?如果是，可以示例一下吗?**

  > 基本上，Flask是一个简单的框架，其行为与MVC框架相同。所以MVC是Flask的完美选择. 

- **解释Python Flask中的数据库连接?**

  > Flask可用于大多数RDBMS，例如PostgreSQL，SQLite和MySQL。但是，要连接数据库，我们必须使用Flask-SQLAlchemy扩展。它使开发过程中的数据库交互和管理变得容易，而无需编写原始SQL查询。此外，原始SQL查询容易受到SQL注入攻击。对于使用NoSQL数据存储（例如MongoDB），我们可以使用Flask-MongoEngine扩展。
  >
  > ##### python中的数据库连接有两种方式
  >
  > - 在脚本中以用第三方库正常连接，用sql语句正常操作数据库，如mysql关系型数据库的pymsql库
  > - 用ORM来进行数据库连接，flask中典型的flask_sqlalchemy，已面向对象的方式进行数据库的连接与操作

- **什么是wsgi?**

  > WSGI（Web Server Gateway Interface，Web 服务器网关接口）则是Python语言中1所定义的Web服务器和Web应用程序之间或框架之间的通用接口标准。
  > WSGI就是一座桥梁，桥梁的一端称为服务端或网关端，另一端称为应用端或者框架端，WSGI的作用就是在协议之间进行转化。WSGI将Web组件分成了三类：Web 服务器（WSGI Server）、Web中间件（WSGI Middleware）与Web应用程序（WSGI Application）。
  > Web Server接收HTTP请求，封装一系列环境变量，按照WSGI接口标准调用注册的WSGI Application，最后将响应返回给客户端

- **Flask蓝图的作用?**

  > 蓝图Blueprint实现模块化的应用
  >
  > book_bp = Blueprint(‘book’, name）创建蓝图对象
  > 蓝图中使用路由@book_bp.route(‘url’) 
  > 在另一.py文件里导入和注册蓝图
  >
  > from book import book_bp app.register_blueprint(book_bp)
  > 作用
  >
  > 将不同的功能模块化
  > 构建大型应用
  > 优化项目结构
  > 增强可读性,易于维护（跟Django的view功能相似）

  ```python
  book_bp = Blueprint(‘book’, name）创建蓝图对象
  
  蓝图中使用路由@book_bp.route(‘url’) 
  在另一.py文件里导入和注册蓝图
  
  from book import book_bp app.register_blueprint(book_bp)
  ```

- **谈谈restful?**

  > 网络上的所有事物都被抽象为资源, 每个资源都有一个唯一的资源标识符,同一个资源具有多种表现形式(xml,json等),对资源的各种操作不会改变资源标识符, 所有的操作都是无状态的.
  >   在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。
  >   Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。
  >   在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。Hypermedia 是应用程序状态的引擎，资源表示通过超链接互联

  > - REST：Representational State Transfer 的缩写，翻译：“具象状态传输”。一般解释为“表现层状态转换”。
  > - REST 是设计风格而不是标准。是指客户端和服务器的交互形式。我们需要关注的重点是如何设计
  > - REST 风格的网络接口。
  >
  > ### REST 的特点
  >
  > 1. 具象的。一般指表现层，要表现的对象就是资源。比如，客户端访问服务器，获取的数据就是资源。比如文字、图片、音视频等。
  > 2. 表现：资源的表现形式。txt 格式、html 格式、json 格式、jpg 格式等。浏览器通过URL 确定资源的位置，但是需要在HTTP 请求头中，用Accept 和Content-Type 字段指定，这两个字段是对资源表现的描述。
  > 3. 状态转换：客户端和服务器交互的过程。在这个过程中，一定会有数据和状态的转化，这种转化叫做状态转换。其中，GET 表示获取资源，POST 表示新建资源，PUT 表示更新资源，DELETE 表示删除资源。HTTP 协议中最常用的就是这四种操作方式。
  >
  > ### RESTful 架构
  >
  > 1. 每个URL 代表一种资源；
  > 2. 客户端和服务器之间，传递这种资源的某种表现层；
  > 3. 客户端通过四个http 动词，对服务器资源进行操作，实现表现层状态转换。

- **列举Http请求中常见的请求方式?**

  > tcp、udp

- **Flask 中请求钩子的理解?**

  > Flask支持如下四种请求钩子：
  >
  > before_first_request
  > 在处理第一个请求前执行
  >
  > before_request
  > 在每次请求前执行
  > 如果在某修饰的函数中返回了一个响应，视图函数将不再被调用
  > after_request
  > 如果没有抛出错误，在每次请求后执行
  > 接受一个参数：视图函数作出的响应
  > 在此函数中可以对响应值在返回之前做最后一步修改处理
  > 需要将参数中的响应在此参数中进行返回
  > teardown_request
  > 在每次请求后执行（就算有错误抛出也要执行）
  > 接受一个参数：错误信息，如果有相关错误抛出

  ```python
  @api.after_request
  def after_request(response):
  """设置默认的响应报文格式为 application/json"""
  	# 如果响应报文 response 的 Content-Type 是以 text 开头，则将其改为
  	# 默认的 json 类型
  	if response.headers.get("Content-Type").startswith("text"):
  		response.headers["Content-Type"] = "application/json"
  	return respon
  ```

  

# MySQL

### MVVC

##### 1. 事物的特性

- 原子性：一个事物是一个最小的操作单位（原子性），多条sql语句在一个事物中要么同时成功，要么同时失败
- 一致性：事务提交之前喝回滚之后的数据是一致的
- 持久性：事物一旦提交，对数据的影响是持久的
- 隔离性：多个事物在并发访问下，提供了一套隔离机制，不同的隔离级别会有不同的并发效果 

##### 2. 事物的隔离级别

read uncommitted（读未提交）：在一个事物中读取到的另一个还没有提交的数据，会出现——`脏读`

read committed（读已提交）：已经解决了脏读问题，在一个事物中只能读取另一个事物已提交的数据，这种情况会出现`不可重复读`的问题：在事物中重复读数据，数据的内容是不一样的

repeatable read（可重复读）（默认级别）：在一个事物中每次读取到的数据都是一致的，不会出现脏读和不可重复读的问题。但是会出现——虚读（幻读）：两个事物中同时查询了表中数据，一个事物提交了数据更改，另一个事物提交了相同的数据更改会提示`主键重复`，但是这个事物查询到的数据并没有相同主键的id。因为MVCC的版本控制问题，事物A提交了数据，事物B查询的数据不是最新的数据，但是每次做写操作时MVCC都会先去查最新的版本，而再最新的版本中已经有了相同的主键，所以事物B无法二次插入。但是因为查询的数据并没有相同的主键所以仿佛是幻觉一样。

解决虚读：通过上行锁解决虚读问题。

上行锁成功：其他事物需要等待该条数据成功执行后再执行，哪怕插入相同数据其余事物也会等待后失败。

上行锁失败：其他事物正在对该条数据做写入操作（InnoDB在事物中对数据做写操作自动上行锁），所以该事物无法直接上行锁直到其他事物提交数据后该事物才能上行锁程功。如果其他事物和该事物插入的数据一样，该事物上行锁的select会有数据，再对比该数据和该事物要插入的数据对比选择是否继续插入数据。

Serializable（串行化）：串行化的隔离级别不允许任何并发发生，不存在任何并发问题。相当于锁表，性能非常差，一般都不考虑。

#### 3.MVCC思想解读

MySQL在读和写的操作中，对读的性能做了并发的保障，让所有的读都是快照读，对于写的时候进行版本控制，如果真实数据的版本比快照的版本要新，那么写之前就要进行版本（快照）更新，这样就可以既能够提高读的并发性，又能够保证写的数据安全



# Redis

穿透：

大量访问无效URL，缓存没有只能在数据库里查找，增加数据库压力，但数据库也没有的无效访问

击穿

某个缓存key过期，瞬时间对该数据大量访问（如热搜），导致数据库压力增大

雪崩

大量缓存key集中过期，导致大量访问查询数据库，导致数据库压力增大

分布式锁：多台机器上同一把锁

独占锁

setex key value nx ex second（nx：上锁 ex：设置过期时间）

# RabbitMQ



# Docker



# Git

