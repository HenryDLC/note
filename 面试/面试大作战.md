# Python
参考：

大厂面经：https://learnku.com/articles/39504

110道题：[python面试题答案.md](./python面试题答案.md)

垃圾回收：https://blog.csdn.net/xiongchengluo1129/article/details/80462651

- **三次握手 / 四次挥手的过程？**

> ​	参考：
>
> https://juejin.cn/post/6844904070000410631
>
> http://www.justdojava.com/2021/03/28/tcp/

三次握手：

1. 刚开始客户端和服务端都是处于关闭的状态，而且服务器 B 端一直处于监听的状态，时刻监听是否有建立连接的请求；
2. 当有客户端需要建立连接的时候就会发送一个确定连接的报文，此报文是同步报文SYN = 1，并且会生成一个随机的序号 seq = x，这是第一次握手；
3. 当服务端接收到请求连接报文的时候，会发送一个同步报文确认报文，此报文 SYN = 1，并且 ACK = 1，同时服务端也会随机生成一个 seq = y，并将 ack 设置成 x + 1，回传给客户端，这是第二次握手；
4. 当客户端接收到服务端的 ACK 报文后，会回复一个 ACK 确认报文，用于确认确认报文已经收到，此报文 ACK = 1，seq = x + 1, ack = y + 1，这是第三次握手；

> 这里有个点说明一下：大写的 ACK 表示报文的类型是确认报文，小写的 ack 是报文里面的确认号，这个确认号是上一次握手对方的 seq 值加 1 得到。

四次挥手：

1. 客户端发起 FIN 断开连接的报文，携带随机生成的 seq 值 u，发送给服务端，并且自己处于 FIN-WSIT 状态，这是第一次挥手；
2. 服务端接收到 FIN 报文后，回复一个确认报文，其中 ACK = 1，随机生成一个 seq，以及 ack = u + 1，这是第二次挥手；
3. 当服务端数据发送完了过后，再发送一个 FIN 报文给客户端，通知客户端，服务端准备关闭连接了，此报文 FIN = 1，ACK = 1，ack = u + 1，seq = w，这是第三次挥手；
4. 当客户端收到 FIN 确认报文时再发送一个FIN 的确认报文，其中 ACK = 1，seq = u + 1，ack = w + 1，并进入 TIME-WAIT 状态，当等待 2MSL 后关闭连接，这是第四次挥手。



- **为什么要三次握手和四次挥手？**

  1. 为什么握手要三次，挥手却要四次呢？

     那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候有数据在传输，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。

  2. 为什么客户端在第四次挥手后还会等待 2MSL？

     等待 2MSL 是因为保证服务端接收到了 ACK 报文，因为网络是复杂了，很有可能 ACK 报文丢失了，如果服务端没接收到 ACK 报文的话，会重新发送 FIN 报文，只有当客户端等待了 2MSL 都没有收到重发的 FIN 报文时就表示服务端是正常收到了 ACK 报文，那么这个时候客户端就可以关闭了。

- **tcp？udp？http？ip ?属于哪些层？作用？**

  > tcp、udp：传输层
  >
  > 在此层中，它提供了节点间的数据传送，应用程序之间的通信服务，主要功能是数据格式化、数据确认和丢失重传等。如传输控制协议(TCP)、用户数据报协议(UDP)等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。

  

  > http：应用层 
  >
  > 应用程序间沟通的层，如简单电子邮件传输(SMTP)、文件传输协议(FTP)、网络远程访问协议(Telnet)等。

  

  > ip：网络层
  >
  > 接收IP数据报并进行传输，从网络上接收物理帧，抽取IP数据报转交给下一层，对实际的网络媒体的管理，定义如何使用实际网络(如Ethernet、Serial Line等)来传送数据。

  

- **TCP 具体是通过怎样的方式来保证数据的顺序化传输、可靠传输呢？**

> 1. 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认
>
> 2. 如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。
>
> 3. 接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等
>
> 4. 接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理

- **python 中可变数据类型和不可变数据类型？**

> 不可变：`int`（整型）、`string`（字符串）、`tuple`（元组）
>
> 可变：set（集合）、list（列表）、dict（字典）

- **非关系数据库可以做什么？其中关系数据库不可以吗？为什么？非关系数据库和关系数据库的区别。**

  > **关系型与非关系型数据库的比较**
  >
  > 1.成本:Nosql数据库很容易部署，基本上是开源软件，无需像Oracle那样花费大量成本购买，比关系数据库便宜。
  >
  > 2.查询速度:Nosql数据库将数据存储在高速缓存中，不需要对SQL层进行分析。关系数据库在硬盘上存储数据，自然的查询速度远比Nosql数据库慢。
  >
  > 3.存储数据的格式：Nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。
  >
  > 4.扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。Nosql基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
  >
  > 5.持久存储：Nosql不使用于持久存储，海量数据的持久存储，还是需要关系型数据库
  >
  > 6.数据一致性：非关系数据库通常强调数据的最终一致性，而不是像关系数据库那样强烈的数据一致性，以及从非关系数据库读取的数据可能仍处于中间状态，Nosql不提供对事务的处理。

- **输入 url 之后显示的网页的全过程？**

  > https://zhuanlan.zhihu.com/p/133906695

- **服务器上为什么要进行反向代理？不进行反向代理外面访问端口就不能访问了吗？**

  > 反向代理（ReverseProxy）是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端,简单来说就是真实的服务器不能直接被外部网络访问,想要访问必须通过代理。

  > 不进行反向代理外面访问端口可以访问，但反向代理服务器可以做的更好

- **get/post 区别？**

  > - GET在浏览器回退时是无害的，而POST会再次提交请求。
  > - GET产生的URL地址可以被Bookmark，而POST不可以。
  > - GET请求会被浏览器主动cache，而POST不会，除非手动设置。
  > - GET请求只能进行url编码，而POST支持多种编码方式。
  > - GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
  > - GET请求在URL中传送的参数是有长度限制的，而POST没有。
  > - 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
  > - GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
  > - GET参数通过URL传递，POST放在Request body中

- **nginx 作用？谁来做监听？**

  > nginx服务器有什么作用？
  >
  > 1、反向代理
  >
  > 2、负载均衡
  >
  > 3、动静分离

- **装饰器的作用？**

  参考：https://foofish.net/python-decorator.html

  > 装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

- **进程和线程？两个的区别？**

  > 进程：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程
  >
  > 
  >
  > 线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。
  >
  > 
  >
  > 进程与线程的区别总结
  >
  > 线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。
  >
  > 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
  >
  > 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
  >
  > 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
  >
  > 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
  >
  > 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
  >
  > 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

- **同进程中的不同线程如何通信？**

  > 1. 线程间需要通信，使用全局变量需要加锁。
  > 2. 使用`queue`模块，可在线程间进行通信，并保证了线程安全。
  >
  > 

- **线程共享堆栈吗？**
  参考：https://xchcloud.cn/死磕-python与多线程多进程/

  > 堆：是大家共有的空间，分**全局堆**和**局部堆**。**全局堆**就是所有没有分配的空间，**局部堆**就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是**内存泄漏**。
  >
  > 栈：是个**线程独有**的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe 的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ 寄存器。**栈空间不需要在高级语言里面显式的分配和释放**。

- **python 垃圾回收**

  > https://zhuanlan.zhihu.com/p/83251959

  > 引用计数：
  >
  > 每个对象里面有一个引用计数器，对象被引用+1删除-1，优点是逻辑简单缺点是需要维护一个计数器而且对循环引用无解
  >
  > 解决循环引用：
  >
  > **标记-清除”(Mark and Sweep)**：(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)
  >
  > 
  >
  > 分代回收：
  >
  > 在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过**“分代回收”(Generational Collection)**以空间换时间的方法提高垃圾回收效率
  >
  > 1. python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。
  >
  > 2. gc的扫描在什么时候会被触发呢?答案是当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。
  >
  > 
  >
  > 总结：
  >
  > 总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。

  > python的内存管理是通过引用计数+清理来完成的。因此python的垃圾回收机制，很大一部分主要是处理引用计数无法解决的循环引用。
  > 1、标记清除算法：算法分为“标记”和“清除”两个阶段，首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。有两个不足：一是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作
  > 2、复制算法：将内存分为两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对一整块内存回收，内存分配时候也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配即可，实现简单，运行高效。缺点是一次只能使用一部分内存，会有一些浪费。一般新生代会选择这种算法。
  > 3、标记-整理算法：复制算法存在两个问题，1）会浪费50%的空间 2）如果被使用的内存中所有对象都100%存活的极端情况，就需要有额外的空间进行分配担保，因此老年代一般不能直接选用复制算法。有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”一样，后续步骤让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
  > 4、分代回收算法：分代回收算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。比如新生代和老年代，不同代使用不同的回收算法。比如新生代使用复制算法，而老年代使用标记-清除或标记-整理算法

- **软件工程的单例模式 / 软件工程有哪些模式**

  ```python
  def singleton(cls):
  	_instance = {}
  	
  	def inner():
  		if cls not in _instance:
  			_instance[cls] = cls()
  		return _instance[cls]
  	return inner
  
  @singleton
  class Cls(object):
  	def __init__(self):
  		pass
  		
  cls1 = Cls()
  cls2 = Cls()
  print(id(cls1) == id(cls2))
  ```
  
  

# Flask

https://www.shangmayuan.com/a/6856476b555f4c4ab9d64ef3.html

https://blog.csdn.net/thanlon/article/details/100718075

https://blog.csdn.net/qq_41891803/article/details/81272575

https://www.modb.pro/db/211218

应用上下文：

https://blog.csdn.net/feit2417/article/details/80735590

https://www.jianshu.com/p/7a7efbb7205f

https://blog.tonyseek.com/post/the-context-mechanism-of-flask/

- **Flask框架的优点**

  > Flask是一个Python编写的Web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。

- **Flask框架依赖组件**

  > - Route(路由)
  > - templates(模板)
  > - Models(orm模型)
  > - blueprint(蓝图)
  > - Jinja2模板引擎

- **列举使用过的Flask第三方组件**

  > - `flask_bootstrap`
  > - `flask-WTF`
  > - `flask_sqlalchemy`
  > - `werkzurg`
  > - `DBUtils`
  > - `jinjia二`
  > - `redis`
  > - `sql`

- **简述Flask上下文管理流程**

  > 每次有请求过来的时候，flask 会先创建当前线程或者进程需要处理的两个重要上下文对象，把它们保存到隔离的栈里面，这样视图函数进行处理的时候就能直接从栈上获取这些信息。

  1. 请求到来时，将session和request封装到ctx对象中；
  2. 对session作补充；
  3. 将包含了request和session的ctx对象放到一个容器中（每一个请求都会根据线程/协程加一个惟一标识）；
  4. 视图函数使用的时候须要根据当前线程或协程的惟一标识，获取ctx对象，再取ctx对象中取request和session（视图函数使用的时候，须要根据当前线程获取数据。）5.请求结束时，根据当前线程/协程的惟一标记，将这个容器上的数据移除。

- **Flask中的g的做用**

  > Flask的g对象用作全局命名空间，用于在应用程序上下文中保存任何数据。g对象不适用于在请求之间存储数据。从某种意义上说，字母g代表global。在某些情况下，当您需要在应用程序上下文中保留全局变量，而不是创建全局变量时，最好使用g对象，因为Flask中的每个请求都有一个单独的g对象。Flask的g对象使我们免于意外修改自定义全局变量。

- **Flask中上下文管理主要涉及到了哪些相关的类，这些类的主要做用**

  > `1. LocalStack它帮助咱们在local中把一个列表维护成一个栈，方便咱们对列表中的数据进行添加和维护，有了LocalStack操做更加便捷。`
  >
  > `2. Local帮助咱们为每一个线程/协程开辟空间`fla

- **为何Flask要把Local对象中的值stack维护成一个列表**

  > ```python
  > # 因为通过维护成列表，可以实现一个栈的数据结构，进栈出栈时只取一个数据，巧妙的简化了问题。
  > # 还有，在多app应用时，可以实现数据隔离；列表里不会加数据，而是会生成一个新的列表
  > # local是一个字典，字典里key（stack）是唯一标识，value是一个列表
  > ```

- **Flask中多app应用是怎么完成**

  > 请求进来时，可以根据URL的不同，交给不同的APP处理
  >
  > 使用Flask类建立不一样的app对象，而后借助DispatcherMiddleware类来实现

- **在Flask中实现WebSocket须要什么组件**

  > flask_socketio

- **wtforms组件的做用**

  > WTForms是一个支持多个web框架的form组件，主要用于对用户请求数据进行验证。
  >
  > `wtforms组件有两个做用，自动生成html标签和对用户请求数据进行校验。`session

- **Flask框架默认session的处理机制**

  > Flask的默认session利用了Werkzeug的SecureCookie，把信息做序列化(pickle)后编码(base64)，放到cookie里了。
  >
  > 过期时间是通过cookie的过期时间实现的。
  >
  > 为了防止cookie内容被篡改，session会自动打上一个叫session的hash串，这个串是经过session内容、SECRET_KEY计算出来的，看得出，这种设计虽然不能保证session里的内容不泄露，但至少防止了不被篡改
  >
  > 
  >
  > 当请求刚进来时，Flask读取cookie中session对应的值，将该值解密并反序列化为字典，放入内存以便视图函数使用。 当请求结束时，Flask会读取内存中字典的值，进行序列化加密，写入到用户的cookie中。

- **解释Flask框架中的Local对象和threading.local对象的区别**

  > `Local对象是根据threading.local作的app

- **Flask中 blinker 是什么**

  > ```python
  > request_started = _signals.signal('request-started')                # 请求到来前执行
  > request_finished = _signals.signal('request-finished')              # 请求结束后执行
  >  
  > before_render_template = _signals.signal('before-render-template')  # 模板渲染前执行
  > template_rendered = _signals.signal('template-rendered')            # 模板渲染后执行
  >  
  > got_request_exception = _signals.signal('got-request-exception')    # 请求执行出现异常时执行
  >  
  > request_tearing_down = _signals.signal('request-tearing-down')      # 请求执行完毕后自动执行（无论成功与否）
  > appcontext_tearing_down = _signals.signal('appcontext-tearing-down')# 请求上下文执行完毕后自动执行（无论成功与否）
  >  
  > appcontext_pushed = _signals.signal('appcontext-pushed')            # 请求上下文push时执行
  > appcontext_popped = _signals.signal('appcontext-popped')            # 请求上下文pop时执行
  > message_flashed = _signals.signal('message-flashed')                # 调用flask在其中添加数据时，自动触发
  > ```
  >
  > 

- **SQLAlchemy中的session和scoped_session的区别**

  > ```
  > 使用的scoped_session是基于Threading.Local实现的，而session并非。
  > ```

- **SQLAlchemy如何执行原生SQL**

  > ```python
  > # 两种SQLAlchemy可以执行原生sql的方式，第一种是通过session(会话)对象执行execute方法，第二种是通过cursor(游标)对象执行execute方法。
  > 
  > """
  > 第一种是：
  > """
  > session = scoped_session(SessionFactory)
  > session.execute('insert users(name) values(:value)', params={'value': 'thanlon'})
  > 
  > """
  > 第二种是：
  > """
  > conn = engine.raw_connection()
  > cursor = conn.cursor()
  > cursor.execute('select * from users')
  > ```
  >
  > 

- **ORM的实现原理**

  > 概念： 对象关系映射（Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。
  >
  > 详细介绍：让我们从O/R开始。字母O起源于”对象”(Object),而R则来自于”关系”(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。 
  > 当你开发一个应用程序的时候(不使用O/R Mapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 
  > ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。
  >
  > ORM技术特点：
  >
  > 1.提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 
  > 2.ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。

- **DBUtils模块的做用**

  > DBUtils模块的作用是实现数据库连接池，是为了解决“多线程情况下请求比较多时性能降低”的问题。

- **SQLAchemy中如何为表设置引擎和字符编码**

  > ```python
  > # 设置引擎编码方式为utf8。    
  > engine = create_engine("mysql+pymysql://user:password@127.0.0.1:3306/db01?charset=utf8")
  > 
  > # 设置数据库表编码方式为utf8class UserType(Base):    
  > class UserType(Base):
  >     __tablename__ = 'usertype'
  >     id = Column(Integer, primary_key=True)
  >     caption = Column(String(50), default='管理员')
  >     # 添加配置设置编码
  >     __table_args__ = {
  >         'mysql_charset':'utf8'
  >     }
  > 
  > ```
  >
  > 

- **SQLAchemy中如何设置联合惟一索引**

  > ```python
  > # 首先在中间表(关联表)的类中加入__table_args__ 字段，然后实例化UniqueConstraint类并放入一个元组中，最后把这个元组赋值给__table_args__。用代码表示如下：
  > 
  > __table_args__ = (
  >         UniqueConstraint('student_id', 'course_id', name='uc_student_course'),  # 联合唯一索引
  >     )
  > ```
  >
  > 

- **Flask请求相关的数据和Django的区别**

  > ```
  > Flask是直接调用request对象来请求相关的数据，而Django是经过参数传递实现的。
  > ```

- **Flask和Django最大的区别**

  > Flask
  >
  > Flask确实很“轻”，不愧是Micro Framework，从Django转向Flask的开发者一定会如此感慨，除非二者均为深入使用过
  > Flask自由、灵活，可扩展性强，第三方库的选择面广，开发时可以结合自己最喜欢用的轮子，也能结合最流行最强大的Python库
  > 入门简单，即便没有多少web开发经验，也能很快做出网站
  > 非常适用于小型网站
  > 非常适用于开发web服务的API
  > 开发大型网站无压力，但代码架构需要自己设计，开发成本取决于开发者的能力
  > 各方面性能均等于或优于Django
  > Django自带的或第三方的好评如潮的功能，Flask上总会找到与之类似第三方
  > Flask灵活开发，Python高手基本都会喜欢Flask，但对Django却可能褒贬不
  > Flask与关系型数据库的配合使用不弱于Django，而其与NoSQL数据库的配合远远优于Django
  > Flask比Django更加Pythonic，与Python的philosophy更加吻合
  >
  > 
  >
  > Django
  >
  > Django太重了，除了web框架，自带ORM和模板引擎，灵活和自由度不够高
  > Django能开发小应用，但总会有“杀鸡焉用牛刀”的感觉
  > Django的自带ORM非常优秀，综合评价略高于SQLAlchemy
  > Django自带的模板引擎简单好用，但其强大程度和综合评价略低于Jinja2
  > Django自带ORM也使Django与关系型数据库耦合度过高，如果想使用MongoDB等NoSQL数据，需要选取合适的第三方库，且总感觉Django+SQL才是天生一对的搭配，Django+NoSQL砍掉了Django的半壁江山
  > Django目前支持Jinja等非官方模板引擎
  > Django自带的数据库管理app好评如潮
  > Django非常适合企业级网站的开发：快速、靠谱、稳定
  > Django成熟、稳定、完善，但相比于Flask，Django的整体生态相对封闭
  > Django是Python web框架的先驱，用户多，第三方库最丰富，最好的Python库，如果不能直接用到Django中，也一定能找到与之对应的移植
  > Django上手也比较容易，开发文档详细、完善，相关资料丰富

- **Flask若是开了两个进程，有几个local对象**

  > 上线文：https://blog.csdn.net/feit2417/article/details/80735590

- **Flask-WTF是什么，有什么特点？**

  > Flask的简单WTForms集成，包含CSRF、文件上传和Recaptcha集成。
  >
  > flask-wtf可以保护表单免受跨站请求伪造（CSRF）的攻击,恶意网站将请求发送到被攻击者已登录的其他网站时就会引发CSRF

- **Flask脚本的常用方式是什么?**

  > - 在shell中运行脚本文件
  > - 在python编译器中run

- **如何在Flask中访问会话?**

  > 一个会话基本上允许记住从一个请求到另一个请求的信息。在Flask中，它使用签名的cookie，以便用户可以查看会话内容并进行修改。用户可以修改会话，只要它有密钥Flask.secret_key。
  >
  > 
  >
  > 会话（seesion）会话数据存储在服务器上。 会话是客户端登录到服务器并注销的时间间隔。 需要在此会话中进行的数据存储在服务器上的临时目录中。
  > from flask import session导入会话对象
  > session[‘name’] = ‘admin’给会话添加变量
  > session.pop(‘username’, None)删除会话的变量

- **Flask是一个MVC模型吗?如果是，可以示例一下吗?**

  > 基本上，Flask是一个简单的框架，其行为与MVC框架相同。所以MVC是Flask的完美选择. 

- **解释Python Flask中的数据库连接?**

  > Flask可用于大多数RDBMS，例如PostgreSQL，SQLite和MySQL。但是，要连接数据库，我们必须使用Flask-SQLAlchemy扩展。它使开发过程中的数据库交互和管理变得容易，而无需编写原始SQL查询。此外，原始SQL查询容易受到SQL注入攻击。对于使用NoSQL数据存储（例如MongoDB），我们可以使用Flask-MongoEngine扩展。
  >
  > ##### python中的数据库连接有两种方式
  >
  > - 在脚本中以用第三方库正常连接，用sql语句正常操作数据库，如mysql关系型数据库的pymsql库
  > - 用ORM来进行数据库连接，flask中典型的flask_sqlalchemy，已面向对象的方式进行数据库的连接与操作

- **什么是wsgi?**

  > WSGI（Web Server Gateway Interface，Web 服务器网关接口）则是Python语言中1所定义的Web服务器和Web应用程序之间或框架之间的通用接口标准。
  > WSGI就是一座桥梁，桥梁的一端称为服务端或网关端，另一端称为应用端或者框架端，WSGI的作用就是在协议之间进行转化。WSGI将Web组件分成了三类：Web 服务器（WSGI Server）、Web中间件（WSGI Middleware）与Web应用程序（WSGI Application）。
  > Web Server接收HTTP请求，封装一系列环境变量，按照WSGI接口标准调用注册的WSGI Application，最后将响应返回给客户端

- **Flask蓝图的作用?**

  > 蓝图Blueprint实现模块化的应用
  >
  > book_bp = Blueprint(‘book’, name）创建蓝图对象
  > 蓝图中使用路由@book_bp.route(‘url’) 
  > 在另一.py文件里导入和注册蓝图
  >
  > from book import book_bp app.register_blueprint(book_bp)
  > 作用
  >
  > 将不同的功能模块化
  > 构建大型应用
  > 优化项目结构
  > 增强可读性,易于维护（跟Django的view功能相似）

  ```python
  book_bp = Blueprint(‘book’, name）创建蓝图对象
  
  蓝图中使用路由@book_bp.route(‘url’) 
  在另一.py文件里导入和注册蓝图
  
  from book import book_bp app.register_blueprint(book_bp)
  ```

- **谈谈restful?**

  > 网络上的所有事物都被抽象为资源, 每个资源都有一个唯一的资源标识符,同一个资源具有多种表现形式(xml,json等),对资源的各种操作不会改变资源标识符, 所有的操作都是无状态的.
  >   在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。
  >   Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。
  >   在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。Hypermedia 是应用程序状态的引擎，资源表示通过超链接互联

  > - REST：Representational State Transfer 的缩写，翻译：“具象状态传输”。一般解释为“表现层状态转换”。
  > - REST 是设计风格而不是标准。是指客户端和服务器的交互形式。我们需要关注的重点是如何设计
  > - REST 风格的网络接口。
  >
  > ### REST 的特点
  >
  > 1. 具象的。一般指表现层，要表现的对象就是资源。比如，客户端访问服务器，获取的数据就是资源。比如文字、图片、音视频等。
  > 2. 表现：资源的表现形式。txt 格式、html 格式、json 格式、jpg 格式等。浏览器通过URL 确定资源的位置，但是需要在HTTP 请求头中，用Accept 和Content-Type 字段指定，这两个字段是对资源表现的描述。
  > 3. 状态转换：客户端和服务器交互的过程。在这个过程中，一定会有数据和状态的转化，这种转化叫做状态转换。其中，GET 表示获取资源，POST 表示新建资源，PUT 表示更新资源，DELETE 表示删除资源。HTTP 协议中最常用的就是这四种操作方式。
  >
  > ### RESTful 架构
  >
  > 1. 每个URL 代表一种资源；
  > 2. 客户端和服务器之间，传递这种资源的某种表现层；
  > 3. 客户端通过四个http 动词，对服务器资源进行操作，实现表现层状态转换。

- **列举Http请求中常见的请求方式?**

  > tcp、udp

- **Flask 中请求钩子的理解?**

  > Flask支持如下四种请求钩子：
  >
  > before_first_request
  > 在处理第一个请求前执行
  >
  > before_request
  > 在每次请求前执行
  > 如果在某修饰的函数中返回了一个响应，视图函数将不再被调用
  > after_request
  > 如果没有抛出错误，在每次请求后执行
  > 接受一个参数：视图函数作出的响应
  > 在此函数中可以对响应值在返回之前做最后一步修改处理
  > 需要将参数中的响应在此参数中进行返回
  > teardown_request
  > 在每次请求后执行（就算有错误抛出也要执行）
  > 接受一个参数：错误信息，如果有相关错误抛出

  ```python
  @api.after_request
  def after_request(response):
  """设置默认的响应报文格式为 application/json"""
  	# 如果响应报文 response 的 Content-Type 是以 text 开头，则将其改为
  	# 默认的 json 类型
  	if response.headers.get("Content-Type").startswith("text"):
  		response.headers["Content-Type"] = "application/json"
  	return respon
  ```

  

# MySQL

### MVVC

##### 1. 事物的特性

- 原子性：一个事物是一个最小的操作单位（原子性），多条sql语句在一个事物中要么同时成功，要么同时失败
- 一致性：事务提交之前喝回滚之后的数据是一致的
- 持久性：事物一旦提交，对数据的影响是持久的
- 隔离性：多个事物在并发访问下，提供了一套隔离机制，不同的隔离级别会有不同的并发效果 

##### 2. 事物的隔离级别

read uncommitted（读未提交）：在一个事物中读取到的另一个还没有提交的数据，会出现——`脏读`

read committed（读已提交）：已经解决了脏读问题，在一个事物中只能读取另一个事物已提交的数据，这种情况会出现`不可重复读`的问题：在事物中重复读数据，数据的内容是不一样的

repeatable read（可重复读）（默认级别）：在一个事物中每次读取到的数据都是一致的，不会出现脏读和不可重复读的问题。但是会出现——虚读（幻读）：两个事物中同时查询了表中数据，一个事物提交了数据更改，另一个事物提交了相同的数据更改会提示`主键重复`，但是这个事物查询到的数据并没有相同主键的id。因为MVCC的版本控制问题，事物A提交了数据，事物B查询的数据不是最新的数据，但是每次做写操作时MVCC都会先去查最新的版本，而再最新的版本中已经有了相同的主键，所以事物B无法二次插入。但是因为查询的数据并没有相同的主键所以仿佛是幻觉一样。

解决虚读：通过上行锁解决虚读问题。

上行锁成功：其他事物需要等待该条数据成功执行后再执行，哪怕插入相同数据其余事物也会等待后失败。

上行锁失败：其他事物正在对该条数据做写入操作（InnoDB在事物中对数据做写操作自动上行锁），所以该事物无法直接上行锁直到其他事物提交数据后该事物才能上行锁程功。如果其他事物和该事物插入的数据一样，该事物上行锁的select会有数据，再对比该数据和该事物要插入的数据对比选择是否继续插入数据。

Serializable（串行化）：串行化的隔离级别不允许任何并发发生，不存在任何并发问题。相当于锁表，性能非常差，一般都不考虑。

#### 3.MVCC思想解读

MySQL在读和写的操作中，对读的性能做了并发的保障，让所有的读都是快照读，对于写的时候进行版本控制，如果真实数据的版本比快照的版本要新，那么写之前就要进行版本（快照）更新，这样就可以既能够提高读的并发性，又能够保证写的数据安全



# Redis

穿透：

大量访问无效URL，缓存没有只能在数据库里查找，增加数据库压力，但数据库也没有的无效访问

击穿

某个缓存key过期，瞬时间对该数据大量访问（如热搜），导致数据库压力增大

雪崩

大量缓存key集中过期，导致大量访问查询数据库，导致数据库压力增大

分布式锁：多台机器上同一把锁

独占锁

setex key value nx ex second（nx：上锁 ex：设置过期时间）

# RabbitMQ



# Docker



# Git

