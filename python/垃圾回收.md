# 垃圾回收
### 引用计数
> 当一个对象的内存空间被一个'容器'所引用,比如`a = 'haha'`对象'haha'被a所引用,那么haha的引用就会被+1,如果`b = a`a的对象被b引用,就再做+1操作,但当我们`del`一个引用,那么haha的对象就会被-1处理,当引用计数归零,python解释器就被将haha的内存地址删除,节省资源.
```python
a = 'haha'
b = a
import sys

print(sys.getrefcount(a))  # >>> 5
del b
print(sys.getrefcount(a))  # >>> 4
```
### 分代收集
> 垃圾回收无法回收`循环引用`
###### 循环应用
```python
a = []  # a+1
b = []  # b+1
a.append(b)  # b+1
b.append(a)  # a+1
del a  # a-1
del b  # b-1
# 引用计数 a -> 1 b -> 1
```
> 我们每次创建一个对象,解释器都会将这个对象挂到一个`链`上,解释器会在特定情况下遍历这个`链`对对象进行回收的处理.解释器一共有三条`链`,分别为:零代链条/一代链条/二代链条.默认情况下,每700次一代链条会执行一次一代链条,每执行10次一代链条会执行一次二代链条.

#### 垃圾回收
##### 引用计数
优点:不会停止程序运行
缺点:无法回收循环引用
##### 分代回收
优点:解决循环引用
缺点:会暂时停止程序运行

### gc模块
```python
import gc
# 查看当前分带回收计数器 计数值
print(gc.get_count())  # >>> (14, 7, 6)
# 查看分带回收'阀值'
print(gc.get_threshold())  # >>> (700, 10, 10)
```