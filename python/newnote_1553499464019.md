# 利用私有属性传入参数值
### 传统方式
```python
# 传统方式:利用私有属性传入参数值
class bank(object):
    def __init__(self):
        self.__money = 0

    def set_money(self, num):
        if isinstance(num, int):
            self.__money = num

        else:
            raise Exception("参数错误")

    def get_money(self):
        return self.__money


bank = bank()
bank.set_money(1000)
print(bank.get_money())
```
### property()方法
```python
class bank(object):
    def __init__(self):
        self.__money = 0

    def set_money(self, num):
        if isinstance(num, int):
            self.__money = num

        else:
            raise Exception("参数错误")

    def get_money(self):
        return self.__money

    money = property(get_money, set_money)


bank = bank()
print(bank.money)
bank.money = 1000
print(bank.money)
```

### property装饰器方法
> 定义两个相同名字的方法,一个为读取一个为设置参数.
```python
class bank(object):
    def __init__(self):
        self.__money = 0

    @property
    def money(self):
        return self.__money

    @money.setter
    def money(self, num):
        if isinstance(num, int):
            self.__money = num

        else:
            raise Exception("参数错误")


bank = bank()
print(bank.money)
bank.money = 1000
print(bank.money)
```
### 只读只写属性
```pyth
class bank(object):
    def __init__(self):
        self.__money = 0

    # 如果只有@property装饰器的函数,则默认为只读属性
    @property
    def money(self):
        raise AttributeError('该属性无法读取')

    
    @money.setter
    def money(self, num):
        if isinstance(num, int):
            self.__money = num

        else:
            raise Exception("参数错误")





bank = bank()
print(bank.money) # >>> AttributeError: 该属性无法读取

bank.money = 1000
print(bank.money)
```