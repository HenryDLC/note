# 进程
注:进程是操作系统分配资源的最小单位,进程与进程之间的资源是彼此独立的

> 创建:通过os模块的fork()方法可以创建一个子进程,并且将子进程的PID返回给父进程,将返回值`0`返回给子进程

> 资源:创建子进程的同时,会将所有的资源和当前的运行状态完全复制一份给子进程

> 注意:为了演示下过,我们需要将两个代码块都做sleep(0.1)的处理,每次执行后都可让程序过渡到下个时间片上,如果不对时间处理,在同一时间片上就可以完成循环五遍print()语句的操作

#### os.getpid()
获取当前进程的PID
#### os.getppid()
获取当前进程的父进程PID
#### os.wait()
阻塞, 等待子进程结束并回收资源.
两个返回值:
1. 子进程的PID
2. 子进程结束状态(无异常默认为:0)

```python
import os, time

# 创建一个进程(子进程)
ret = os.fork()

if ret == 0:
    # 子进程
    print('我是子进程PID:{},父进程PPID:{}'.format(os.getpid(), os.getppid()))
    for i in range(10):
        print('我是子进程')
        time.sleep(0.1)
    raise Exception('抛出异常状态')

else:
    # 父进程
    print('我是父进程PID:{},父进程PPID:{}'.format(os.getpid(), os.getppid()))
    for i in range(5):
        print('父进程')
        time.sleep(0.1)

    print('父进程"任务"结束')
    pid, result = os.wait()  # 阻塞, 等待子进程结束并回收资源.两个返回值,子进程的PID和子进程结束状态(无异常默认为:0)
    print('子进程结束,pid为{},结束状态{}'.format(pid,result))

# >>> 我是父进程PID:31516,父进程PPID:17239
# >>> 父进程
# >>> 我是子进程PID:31517,父进程PPID:31516
# >>> 我是子进程
# >>> 我是子进程
# >>> 父进程
# >>> 我是子进程
# >>> 父进程
# >>> 我是子进程
# >>> 父进程
# >>> 我是子进程
# >>> 父进程
# >>> 我是子进程
# >>> 父进程"任务"结束
# >>> 我是子进程
# >>> 我是子进程
# >>> 我是子进程
# >>> 我是子进程
# >>> Traceback (most recent call last):
# >>>   File "/Users/HenryDu/PycharmProjects/untitled/main.py", line 18, in <module>
# >>>     raise Exception('抛出异常状态')
# >>> Exception: 抛出异常状态
# >>> 子进程结束,pid为31517,结束状态256
```
### 孤儿进程
> 父进程结束,子进程还在执行任务
> 子进程交给操作系统进行处理回收

### 僵尸进程
> 子进程任务结束,父进程没有结束且没有对子进程进行资源回收
> 会对系统造成资源浪费,所以要尽量避免僵尸进程存在

## Process
### 使用Process类
```python
from multiprocessing import Process
import os, time


# target=None 子进程需要执行的任务函数
# name=None   给子进程取名,通过p.name查看
# args=(), kwargs={}     给子进程需要执行的任务函数传入不定长参数

def process_fun(*args, **kwargs):
    for i in range(10):
        print('helloworld')
        print(args)
        print(kwargs)
        print('子进程pid:{}'.format(os.getpid()     ))
        time.sleep(0.1)


if __name__ == '__main__':
    p = Process(target=process_fun, args=(1,2), kwargs={'A':'a'}, name='test')  # 创建子进程
    p.start()  # 运行子进程
    print('父进程PID:{}'.format(os.getpid()))
    print(p.name)  # 获取子进程名称
    time.sleep(0.1)
    p.terminate() # 无论子进程任务是否完成,立即终止
    p.join()  # 子进程回收资源 阻塞
    print(p.is_alive())  # 查看子进程是否还在执行
    print('父进程结束')

# >>> 父进程PID:47836
# >>> test
# >>> helloworld
# >>> (1, 2)
# >>> {'A': 'a'}
# >>> 子进程pid:47837
# >>> False
# >>> 父进程结束
```
### 继承Process类
```python
from multiprocessing import Process
import os, time


# target=None 子进程需要执行的任务函数
# name=None   给子进程取名,通过p.name查看
# args=(), kwargs={}     给子进程需要执行的任务函数传入不定长参数

class process_fun(Process):
    def __init__(self, *args, **kwargs):
        super(process_fun, self).__init__()
        self.args = args
        self.kwargs = kwargs
    def run(self):
        for i in range(10):
            print('helloworld')
            print(self.kwargs)
            print('子进程pid:{}'.format(os.getpid()     ))
            time.sleep(0.1)


if __name__ == '__main__':
    p = process_fun(args=(1,2), kwargs={'A':'a'})  # 创建子进程
    p.start()  # 运行子进程
    print('父进程PID:{}'.format(os.getpid()))
    time.sleep(0.1)
    p.terminate() # 无论子进程任务是否完成,立即终止
    p.join()  # 子进程回收资源 阻塞
    print(p.is_alive())  # 查看子进程是否还在执行
    print('父进程结束')

# >>> 父进程PID:48265
# >>> helloworld
# >>> {'args': (1, 2), 'kwargs': {'A': 'a'}}
# >>> 子进程pid:48266
# >>> helloworld
# >>> {'args': (1, 2), 'kwargs': {'A': 'a'}}
# >>> 子进程pid:48266
# >>> False
# >>> 父进程结束
```
## Pool
非阻塞添加任务-进程池
> pool.apply_async(test, (i, ))  非阻塞添加任务

> pool.apply_async(test, (i, ))  # 向进程池添加任务, 非阻塞方式  pool.apply_async(test, (i, ))其中(i, )表示向task(num)传入参数num值
```python
from multiprocessing import Pool
import os, time


def test(num):
    print('开始执行任务{}'.format(num))
    time.sleep(0.1)
    print('结束执行任务{}'.format(num))


pool = Pool(4)

for i in range(10):
    pool.apply_async(test, (i, ))  # 向进程池添加任务, 非阻塞方式  pool.apply_async(test, (i, ))其中(i, )表示向task(num)传入参数num值

pool.close()  # 关闭进程池,不再接收新的任务
pool.join()  # 回收进程池资源


# >>> 开始执行任务0
# >>> 开始执行任务1
# >>> 开始执行任务2
# >>> 开始执行任务3
# >>> 结束执行任务2结束执行任务1
# >>> 结束执行任务0
# >>>
# >>> 开始执行任务4
# >>> 开始执行任务5
# >>> 开始执行任务6
# >>> 结束执行任务3
# >>> 开始执行任务7
# >>> 结束执行任务4
# >>> 开始执行任务8
# >>> 结束执行任务5
# >>> 结束执行任务6
# >>> 开始执行任务9
# >>> 结束执行任务7
# >>> 结束执行任务8结束执行任务9
```

### 阻塞添加任务-进程池
> pool.apply(test, (i, ))  # 向进程池添加任务, 阻塞方式  
```python
from multiprocessing import Pool
import os, time


def test(num):
    print('开始执行任务{}'.format(num))
    time.sleep(0.1)
    print('结束执行任务{}'.format(num))


pool = Pool(4)

for i in range(10):
    pool.apply(test, (i, ))  # 向进程池添加任务, 阻塞方式  pool.apply_async(test, (i, ))其中(i, )表示向task(num)传入参数num值

pool.close()  # 关闭进程池,不再接收新的任务
pool.join()  # 回收进程池资源


# >>> 开始执行任务0
# >>> 结束执行任务0
# >>> 开始执行任务1
# >>> 结束执行任务1
# >>> 开始执行任务2
# >>> 结束执行任务2
# >>> 开始执行任务3
# >>> 结束执行任务3
# >>> 开始执行任务4
# >>> 结束执行任务4
# >>> 开始执行任务5
# >>> 结束执行任务5
# >>> 开始执行任务6
# >>> 结束执行任务6
# >>> 开始执行任务7
# >>> 结束执行任务7
# >>> 开始执行任务8
# >>> 结束执行任务8
# >>> 开始执行任务9
# >>> 结束执行任务9
```

## 同步与异步
异步: 多任务,多个任务之间执行没有先后顺序,可以同时运行,执行的先后顺序不会有什么影响,存在的多条运行主线

同步:  多任务, 多个任务之间执行的时候要求有先后顺序,必须一个先执行完成