# 装饰器
> 本质:装饰器就是一个闭包
## 定义及使用装饰器
```python
import time

# 定义装饰器
def time_log(fun):
    def inner():
        print(time.time())
        fun()
        print(time.time())

    return inner

# 使用装饰器
@time_log
def get_name():
    print('Tom')


get_name()
```
#### 执行过程:
get_name = time_log(get_name) => get_name = inner
get_name() == inner()
1. 调用get_name()
2. 新建一个和调用装饰函数相同名字的变量及(get_name)
3. 调用装饰器函数time_log(),将调用装饰器的函数作为参数传给装饰器,相当于time_log(get_name)
4. 第三步的time_log(get_name)的返回值赋值给第一步创建的和调用装饰器函数同名的变量get_name
5. 因为time_log(get_name)的返回值是inner,所以在我们调用get_name()函数时,就相当于调用了装饰器中的inner()函数,输出的结果也与inner()函数的运行结果相同

## 多层装饰器使用
```python
def fun1(f):
    def inner():
        print("fun1 运行")
        f()
        print('fun1 停止')

    return inner


def fun2(f):
    def inner():
        print('fun2 运行')
        f()
        print('fun2 停止')

    return inner


@fun1
@fun2
def say_hello():
    print('hello world')


say_hello()
# >>> fun1 运行
# >>> fun2 运行
# >>> hello world
# >>> fun2 停止
# >>> fun1 停止
```
#### 执行过程:
1. say_hello = fun1(fun2(say_hello))
2. 调用say_hello函数,启动fun1()装饰器,相当于直接调用fun1()里面的inner()方法.
3. 执行print("fun1 运行")
3. 执行fun1()里面的f()时,获取fun1(fun2(say_hello))里面的fun2(say_hello)参数,调用fun2()装饰器
4. 执行print('fun2 运行')
5. 执行fun2()下面的f(),获取fun2(say_hello)里面的say_hello参数
6. 执行print('hello world')
7. 执行fun2(print('hello world'))下面的print('fun2 停止')
8. 执行fun1(fun2(say_hello))下面的print('fun1 停止')
